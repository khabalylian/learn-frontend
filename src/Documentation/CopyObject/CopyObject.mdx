import Alert from '@mui/material/Alert';
import { CodeEdit, InfoPage } from '../../components/index.jsx';

<InfoPage>
	[https://uk.javascript.info](https://uk.javascript.info/object)
</InfoPage>

# Копіювання об’єктів та посилання

Однією з принципових відмінностей об’єктів від примітивів є те, що об’єкти зберігаються та копіюються “за посиланням”, тоді як примітивні значення: рядки, числа, логічні значення тощо – завжди копіюються “за значенням”.

Це легко зрозуміти, якщо заглянути під капот того, що відбувається, коли ми копіюємо значення.

Почнемо з примітиву, наприклад, рядка.

Запишемо копію ```message``` у ```phrase```:

<CodeEdit text={`
let message = "Привіт!";
let phrase = message;
`}/>

В результаті ми маємо дві незалежні змінні, кожна з яких зберігає рядок ```"Привіт!"```.

Об’єкти поводяться інакше.

Змінна зберігає не сам об’єкт, а його “адресу в пам’яті” – іншими словами “посилання” на нього.

Коли копіюється змінна об’єкта, копіюється посилання, але сам об’єкт не дублюється.

Наприклад:

<CodeEdit text={`
let user = { name: "Іван" };

let admin = user; // копіювання посилання
`}/>

Тепер у нас є дві змінні, кожна з яких зберігає посилання на той самий об’єкт:

Ми можемо використати будь-яку змінну для доступу до об’єкта та модифікації його вмісту:

<CodeEdit text={`
let user = { name: 'Іван' };

let admin = user;

admin.name = 'Петро'; // змінено за посиланням зі змінної "admin"

alert(user.name); // 'Петро', зміни видно з посилання зі змінної "user"
`}/>

## Порівняння за посиланням

Два об’єкти рівні, лише якщо це той самий об’єкт.

Наприклад, тут ```a``` і ```b``` посилаються на той самий об’єкт, отже, вони рівні:

<CodeEdit text={`
let a = {};
let b = a; // копіювання посилання

alert( a == b ); // true, обидві змінні посилаються на той самий об’єкт
alert( a === b ); // true
`}/>

І тут два незалежні об’єкти не рівні, хоча вони схожі (обидва порожні):

<CodeEdit text={`
let a = {};
let b = {}; // два незалежні об’єкти

alert( a == b ); // false
`}/>

## Клонування та злиття об’єктів, Object.assign

Отже, копіювання змінної об’єкта створює ще одне посилання на той самий об’єкт.

Але що, якщо нам потрібно дублювати об’єкт? Створити незалежну копію, клон?

Нам потрібно створити новий об’єкт і відтворити структуру існуючого, перебираючи та копіюючи його властивості.

Наприклад так:

<CodeEdit text={`
let user = {
  name: "Іван",
  age: 30
};

let clone = {}; // новий порожній об’єкт

// скопіюймо в нього всі властивості з user
for (let key in user) {
  clone[key] = user[key];
}

// тепер клон - це повністю незалежний об’єкт з однаковим вмістом
clone.name = "Петро"; // змінемо його вміст

alert( user.name ); // як і раніше Іван залишився в оригінальному об’єкті
`}/>

Також ми можемо використати метод Object.assign для цього.

Його синтаксис:

<CodeEdit text={`
Object.assign(dest, [src1, src2, src3...])
`}/>

* Перший аргумент ```dest``` – це цільовий об’єкт, у який ми будемо копіювати.
* Наступні аргументи ```src1, ..., srcN``` (їх може бути скільки завгодно) – це вихідні об’єкти, з яких ми будемо копіювати.
* Він копіює властивості всіх вихідних об’єктів ```src1, ..., srcN``` у цільовий ```dest```. Іншими словами, властивості всіх аргументів, починаючи з другого, копіюються в перший об’єкт.
* Виклик повертає ```dest```.

Наприклад, ми можемо використовувати його для об’єднання кількох об’єктів в один:

<CodeEdit text={`
let user = { name: "Іван" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// копіює всі властивості з permissions1 та permissions2 у user
Object.assign(user, permissions1, permissions2);

// тепер user = { name: "Іван", canView: true, canEdit: true }
`}/>

Якщо приймаючий об’єкт (user) вже має властивість з таким ім’ям, її буде перезаписано.

## Вкладене клонування
До цього часу ми вважали, що всі властивості ```user``` є примітивами. Але властивості можуть бути посиланнями на інші об’єкти. Що з ними робити?

Наприклад:

<CodeEdit text={`
let user = {
  name: "Іван",
  sizes: {
    height: 182,
    width: 50
  }
};

alert( user.sizes.height ); // 182
`}/>

Тепер при клонуванні недостатньо просто скопіювати ```clone.sizes = user.sizes```, тому що ```user.sizes``` є об’єктом, і він буде скопійований за посиланням. Тому ```clone``` і ```user``` у своїх властивостях ```sizes``` будуть посилатися на той самий об’єкт:

Ось так:

<CodeEdit text={`
let user = {
  name: "Іван",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, той самий об’єкт

// user і clone мають посилання на єдиний об’єкт у властивості sizes
user.sizes.width++;       // міняємо властивість з одного місця
alert(clone.sizes.width); // 51, бачимо результат в іншому об’єкті
`}/>

Щоб це виправити, слід використовувати цикл клонування, який перевіряє кожне значення ```user[key]```, і якщо це об’єкт, то також копіює його структуру. Це називається “глибоким клонуванням”.

Для його реалізації ми можемо використати рекурсію. Або, щоб не винаходити колесо, взяти існуючу реалізацію, наприклад [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep) з бібліотеки JavaScript [lodash](https://lodash.com).

<Alert severity="info" variant="outlined">
	### об’єкти у const-змінних можна змінювати
	Важливим побічним ефектом зберігання об’єктів як посилань є те, що об’єкт, оголошений як const, може бути змінений.

	Наприклад:

<CodeEdit text={`
const user = {
  name: "Іван"
};

user.name = "Петро"; // (*)

alert(user.name); // Петро
`}/>
	Може здатися, що рядок ```(*)``` призведе до помилки, але це не так. Значення у змінній ```user``` є постійним, воно завжди має посилатися на той самий об’єкт, але властивості цього об’єкта можуть змінюватися.
</Alert>