import { CodeEdit, InfoPage, Alerts } from '../../../components/index.jsx';

<InfoPage>
	[https://uk.javascript.info](https://uk.javascript.info/object-methods#this-v-metodakh)
</InfoPage>

# Методи об’єкту, "this"

Об’єкти зазвичай створюються для представлення сутностей реального світу, таких як користувачі, замовлення тощо:

<CodeEdit text={`
let user = {
  name: "Іван",
  age: 30
};
`}/>

І в реальному світі користувач може діяти: вибрати щось із кошика для покупок, авторизуватися, виходити із системи тощо.

Дії представлені в JavaScript функціями у властивостях об’єкта.

## Приклади методів

Для початку навчімо ```user``` вітатися:

<CodeEdit text={`
let user = {
  name: "Іван",
  age: 30
};

user.sayHi = function() {
  alert("Привіт!");
};

user.sayHi(); // Привіт!
`}/>

Тут ми щойно використали Function Expression (функціональний вираз) для створення функції та присвоїли її властивості ```user.sayHi``` об’єкта.

Потім ми викликали її завдяки ```user.sayHi()```. Користувач тепер може говорити!

Функція, яка є властивістю об’єкта, називається його методом.

#### Скорочений запис методу

Існує коротший синтаксис для методів в літералі об’єкта:

<CodeEdit text={`
// цей об’єкт робить те ж саме

user = {
  sayHi: function() {
    alert("Привіт!");
  }
};

// скорочений метод виглядає краще, чи не так?
user = {
  sayHi() { // те ж саме що й "sayHi: function(){...}"
    alert("Привіт!");
  }
};
`}/>

Як було показано, ми можемо опустити ```"function"``` і написати просто ```sayHi()```.

## “this” в методах
Як правило, метод об’єкта повинен отримувати доступ до інформації, що зберігається в об’єкті, для виконання своєї роботи.

Наприклад, коду всередині ```user.sayHi()``` може знадобитися ім’я, що зберігається в об’єкті user.

Для доступу до інформації всередині об’єкта метод може використовувати ключове слово ```this```.

Значенням ```this``` є об’єкт “перед крапкою”, який використовується для виклику методу.

Наприклад:

<CodeEdit text={`
let user = {
  name: "Іван",
  age: 30,

  sayHi() {
    // "this" -- це "поточний об’єкт"
    alert(this.name);
  }

};

user.sayHi(); // Іван
`}/>

Тут під час виконання коду ```user.sayHi()```, значенням ```this``` буде ```user```.

Також можна отримати доступ до об’єкта без цього, посилаючись на нього через зовнішню змінну:

<CodeEdit text={`
let user = {
  name: "Іван",
  age: 30,

  sayHi() {
    alert(user.name); // використовуємо змінну "user" замість "this"
  }

};
`}/>

…Але такий код ненадійний. Якщо ми вирішимо скопіювати user в іншу змінну, напр. ```admin = user``` перезаписати ```user``` чимось іншим, тоді цей код отримає доступ до неправильного об’єкта.

## “this” не являється фіксованим
В JavaScript, ключове слово ```this``` поводить себе не так, як в більшості мов програмування.

В цьому коді немає синтаксичної помилки:

<CodeEdit text={`
function sayHi() {
  alert( this.name );
}
`}/>

Значення ```this``` обчислюється під час виконання і залежить від контексту.

Наприклад, тут одна й та ж функція призначена двом різним об’єктам і має різний “this” при викликах:

<CodeEdit text={`
let user = { name: "Іван" };
let admin = { name: "Адмін" };

function sayHi() {
  alert( this.name );
}

// використовуємо одну і ту ж функцію у двох об’єктах
user.f = sayHi;
admin.f = sayHi;

// виклики функцій, приведені нижче, мають різні this
// "this" всередині функції являється посиланням на об’єкт "перед крапкою"
user.f(); // Іван  (this == user)
admin.f(); // Адмін  (this == admin)

admin['f'](); // Адмін (неважливо те, як звертатися до методу об’єкта -- через крапку чи квадратні дужки)
`}/>

Правило просте: якщо ```obj.f()``` викликано, то ```this``` це ```obj``` під час виконання ```f```. Так що в даному прикладі це ```user``` або ```admin```.

<Alerts severity="info" variant="outlined">
	### Виклик без об’єкта: this == undefined
	Ми можемо навіть викликати функцію взагалі без об’єкта:

<CodeEdit text={`
function sayHi() {
  alert(this);
}

sayHi(); // undefined
`}/>
	В такому випадку ```this``` є undefined в суворому режимі ("use strict"). Якщо ми спробуємо звернутися до ```this.name``` трапиться помилка.

	У несуворому режимі значенням ```this``` в такому випадку буде глобальний об’єкт window. Це – поведінка, яка склалася історично та виправляється завдяки використанню суворого режиму ("use strict").

	Зазвичай такий виклик є помилкою програмування. Якщо всередині функції є ```this```, вона очікує виклику в контексті об’єкта.
</Alerts>

## Стрілочні функції не мають “this”
Стрілочні функції особливі: у них немає “свого” ```this```. Якщо ми посилаємось на ```this``` з такої функції, його значення береться із зовнішньої “нормальної” функції.

Наприклад, тут ```arrow()``` використовує ```this``` із зовнішнього ```user.sayHi()``` методу:

<CodeEdit text={`
let user = {
  firstName: "Ілля",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ілля
`}/>

Це особливість стрілочних функцій є корисною коли ми не хочемо мати окреме ```this```, а лише взяти його із зовнішнього контексту.