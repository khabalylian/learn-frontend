import { CodeEdit, InfoPage } from '../../../components/index.jsx';

<InfoPage>
	[https://uk.javascript.info](https://uk.javascript.info/keys-values-entries)
</InfoPage>

# Деструктуризація

Двома найбільш вживаними структурами даних у JavaScript є ```Object``` та ```Array```.

* Об’єкти дозволяють нам створити єдину сутність, яка зберігатиме дані за ключем.
* Масиви дозволяють нам зібрати елементи даних у впорядкований список.

Деструктуроване присвоєння – це спеціальний синтаксис, що дозволяє нам “розпаковувати” масиви чи об’єкти в купу змінних, оскільки іноді це зручніше.

## Деструктурування масиву

Ось приклад того, як масив деструктурується на змінні:

<CodeEdit text={`
// у нас є масив з іменем та прізвищем
let arr = ["Іван", "Петренко"]

// деструктуроване присвоєння
// встановлює firstName = arr[0]
// та surname = arr[1]
let [firstName, surname] = arr;

alert(firstName); // Іван
alert(surname);  // Петренко
`}/>

Це чудово виглядає в поєднанні зі ```split``` або іншими методами повернення масиву:

<CodeEdit text={`
let [firstName, surname] = "Іван Петренко".split(' ');
alert(firstName); // Іван
alert(surname);  // Петренко
`}/>

#### Залишкові параметри ‘…’

Зазвичай, якщо масив довший від списку зліва, “зайві” елементи опускаються.

Наприклад, тут береться лише два елементи, а решта просто ігнорується:

<CodeEdit text={`
let [name1, name2] = ["Юлій", "Цезар", "Консул", "Римської Республіки"];

alert(name1); // Юлій
alert(name2); // Цезар
// Інші пункти ніде не присвоєні
`}/>

Якщо ми хочемо також зібрати все наступне – ми можемо додати ще один параметр, який отримує “решту”, використовуючи три крапки ```"..."```:

<CodeEdit text={`
let [name1, name2, ...rest] = ["Юлій", "Цезар", "Консул", "Римської Республіки"];

// rest -- це масив елементів, починаючи з 3-го
alert(rest[0]); // Консул
alert(rest[1]); // Римської Республіки
alert(rest.length); // 2
`}/>

Якщо ми хочемо, щоб “типове” значення замінило б відсутнє, ми можемо надати його за допомогою ```=```:

<CodeEdit text={`
// типове значення
let [name = "Гість", surname = "Анонім"] = ["Юлій"];

alert(name);    // Юлій (з масиву)
alert(surname); // Анонім (використовується типове значення)
`}/>

## Деструктурування об’єктів

Деструктуроване присвоєння також працює з об’єктами.

Основний синтаксис такий:

<CodeEdit text={`
let {var1, var2} = {var1:…, var2:…}
`}/>

Ми повинні мати існуючий об’єкт праворуч, який ми хочемо розділити на змінні. Ліва частина містить об’єктоподібний “шаблон” для відповідних властивостей. У найпростішому випадку це список імен змінних у ```{...}```.

Наприклад:

<CodeEdit text={`
let options = {
  title: "Меню",
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Меню
alert(width);  // 100
alert(height); // 200
`}/>

Якщо ми хочемо присвоїти властивість змінній з іншим іменем, наприклад, зробити так, щоб ```options.width``` переходив до змінної з назвою ```w```, то ми можемо встановити ім’я змінної за допомогою двокрапки:

<CodeEdit text={`
let options = {
  title: "Меню",
  width: 100,
  height: 200
};

// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

alert(title);  // Меню
alert(w);      // 100
alert(h);      // 200
`}/>

#### Залишок об’єкту “…”

Ми можемо використовувати шаблон залишкового оператору, так само, як ми робили з масивами. Він не підтримується деякими старішими браузерами (IE, використовуйте Babel для поліфілу), але працює в сучасних.

Це виглядає наступним чином:

<CodeEdit text={`
let options = {
  title: "Меню",
  height: 200,
  width: 100
};

// title = властивість з назвою title
// rest = об’єкт з залишковими властивостями
let {title, ...rest} = options;

// тепер title="Меню", rest={height: 200, width: 100}
alert(rest.height);  // 200
alert(rest.width);   // 100
`}/>

## Вкладене деструктурування

Якщо об’єкт або масив містять інші вкладені об’єкти та масиви, ми можемо використовувати більш складні шаблони з лівого боку для вилучення більш глибоких частин.

<CodeEdit text={`
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Торт", "Пончик"],
  extra: true
};

// деструктурування розподілене на кілька рядків для наочності
let {
  size: { // помістимо тут size
    width,
    height
  },
  items: [item1, item2], // тут призначимо items
  title = "Меню" // немає в об’єкті (використовується типове значення)
} = options;

alert(title);  // Меню
alert(width);  // 100
alert(height); // 200
alert(item1);  // Торт
alert(item2);  // Пончик
`}/>