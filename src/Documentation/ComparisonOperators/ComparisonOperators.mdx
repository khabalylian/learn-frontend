import Alert from '@mui/material/Alert';
import { CodeEdit, InfoPage } from '../../components/index.jsx';

<InfoPage>
	[https://uk.javascript.info](https://uk.javascript.info/comparison)
</InfoPage>


# Оператори порівняння
Багато з операторів порівняння нам відомі з математики.

В JavaScript вони записуються ось так:

* Більше/менше: ```a > b```, ```a < b```.
* Більше/менше або дорівнює: ```a >= b, a <= b```.
* Дорівнює: ```a == b```. Зверніть увагу, для порівняння потрібно використовувати два знаки рівності ```==```. Один знак рівності ```a = b``` означав б присвоєння.
* Не дорівнює: в математиці позначається символом ```≠```, проте в JavaScript записується як ```a != b```.

## Результат порівняння має логічний тип
Всі оператори порівняння повертають значення логічного типу:

* ```true``` – означає “так”, “правильно” або “істина”.
* ```false``` – означає “ні”, “неправильно” або “хибність”.
Наприклад:

<CodeEdit text={`
alert( 2 > 1 );  // true (правильно)
alert( 2 == 1 ); // false (неправильно)
alert( 2 != 1 ); // true (правильно)
`}/>

Результат порівняння можна присвоїти змінній, як і будь-яке інше значення:

<CodeEdit text={`
let result = 5 > 4; // присвоїти результат порівняння змінній result
alert( result ); // true
`}/>

## Порівняння рядків
Щоб визначити, чи один рядок більший за інший, JavaScript використовує так званий “алфавітний” або “лексикографічний” порядок.

Інакше кажучи, рядки порівнюються посимвольно.

Наприклад:

<CodeEdit text={`
alert( 'Я' > 'А' ); // true
alert( 'Соки' > 'Сода' ); // true
alert( 'Комар' > 'Кома' ); // true
`}/>
Алгоритм порівняння рядків досить простий:

1. Порівнюються перші символи обох рядків.
1. Якщо перший символ першого рядка більший (менший) за перший символ другого рядка, то перший рядок більший (менший) за другий. Порівняння закінчено.
1. В іншому випадку, якщо перші символи обох рядків рівні, то таким самим чином порівнюються вже другі символи рядків.
1. Порівняння продовжується до того часу, доки не закінчиться один з рядків.
1. Якщо два рядки закінчуються одночасно, то вони рівні. Інакше, довший рядок вважатиметься більшим.

В прикладах вище, порівняння ```'Я' > 'А'``` завершиться на першому кроці.

Проте друге порівняння слів ```'Соки'``` і ```'Сода'``` буде виконуватися посимвольно:

1. ```С``` дорівнює ```С```.
1. ```о``` дорівнює ```о```.
1. ```к``` більше ніж ```д```. На цьому кроці порівнювання закінчується. Перший рядок більший.

<Alert severity="info" variant="outlined">
	### Використовується кодування Unicode, а не справжній алфавіт
	Такий алгоритм порівняння схожий на алгоритм сортування, який використовується в словниках і телефонних довідниках, проте вони не зовсім однакові.

	Наприклад, в JavaScript має значення регістр символів. Велика буква ```"А"``` не рівна маленькій ```"а"```. Але яка з них більше? Маленька буква ```"а"```. Чому? Тому що маленькі букви мають більший код у внутрішній таблиці кодування, яку використовує JavaScript (Unicode). Ми розглянемо особливості і наслідки цього кодування в розділі [Рядки](https://uk.javascript.info/string).
</Alert>

## Порівняння різних типів
Коли порівнюються значення різних типів, JavaScript конвертує ці значення в числа.

Наприклад:

<CodeEdit text={`
alert( '2' > 1 ); // true, рядок '2' стає числом 2
alert( '01' == 1 ); // true, рядок '01' стає числом 1
`}/>
Логічне значення ```true``` стає ```1```, а ```false``` — ```0```.

Наприклад:

<CodeEdit text={`
alert( true == 1 ); // true
alert( false == 0 ); // true
`}/>

## Строге порівняння
Використання звичайного оператора порівняння ```==``` може викликати проблеми. Наприклад, він не відрізняє ```0``` від ```false```:

<CodeEdit text={`
alert( 0 == false ); // true
`}/>

#### Оператор строгої рівності === перевіряє рівність без перетворення типів.

Іншими словами, якщо ```a``` і ```b``` мають різні типи, то перевірка ```a === b``` негайно поверне результат ```false``` без спроби їхнього перетворення.

Давайте перевіримо:

<CodeEdit text={`
alert( 0 === false ); // false, тому що порівнюються різні типи
`}/>

Оператор строгої рівності робить код більш зрозумілим і залишає менше місця для помилок.

## Порівняння з null і undefined
Поведінка ```null``` і ```undefined``` під час порівняння з іншими значеннями — особливе:

#### При строгому порівнянні ```===```
Ці значення різні, тому що різні їхні типи.

<CodeEdit text={`
alert( null === undefined ); // false
`}/>

#### При нестрогому порівнянні ```==```
Ці значення рівні. Водночас ці значення не рівні значенням інших типів. Це спеціальне правило мови.

<CodeEdit text={`
alert( null == undefined ); // true
`}/>

#### Під час використання математичних операторів та інших операторів порівняння ```< > <= >=```
Значення ```null/undefined``` конвертуються в числа: ```null``` стає ```0```, тоді як ```undefined``` стає ```NaN```.